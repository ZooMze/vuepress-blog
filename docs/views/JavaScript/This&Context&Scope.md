---
title: 执行上下文、作用域、this
date: 2018-05-09
categories:
 - 基础
 - 备忘
tags:
 - JavaScript
---

## 前言

这三个东西, 眼熟, 但是吧经常是就知道个大概, 掌握得不够深刻, 本篇文章就来一并全给总结到位!

那么, 我们就先从作用域开始

## 作用域

::: tip 什么是作用域
**函数或变量的可见区域**
如果函数或变量不在此区域内, 则无法访问
:::

```js
(function func(){// 作用域A
  var a = "a"
  var c = 'c'
  function func1(){ //作用域B
    var a = "aa" // 这里覆盖了a原本的值
    var b = "b"

    console.log(a);
  }
  function func2 () { // 作用域C
    console.log(c)
  }

  console.log(a) // >> `a`
  func1()        // >> `aa`
  func2()        // >> `c`
})()
```

这里能输出c是因为作用域链的关系, 是有**作用域链**的存在, 当前作用域如果没有能访问的变量或函数, 则回去上层作用域查询, 这里 `func2` 就在 `func` 内找到了变量 `c`

### 块级作用域

ES6 引入了块级作用域这个概念, 意味着代码之前区分会更加直观直白, 并且不用担心var 的变量提升和变量污染的问题

::: tip 什么是块级作用域
**在某个花括号对 `{ }` 的内部用 `let` 关键字生声明的变量和函数拥有块级作用域**

块级作用域 和 函数作用域 也可以统称为局部作用域
:::

出于向后（backward）兼容的考虑，在块级作用域中声明的函数依然可以在作用域外部引用来看几个例子对比

```js
{
  function func() {//函数声明
    return 1;
  }
}
console.log(func());//>> 1
```

```js
{
  var func = function() {//未使用let关键字的函数表达式
    return 1;
  }
}
console.log(func());//>> 1
```

上面两个都能正确访问代码块内的函数, 要怎么做到真正的块级作用域咧? 用let就完事了

```js
{
  let func = function() {
    return 1;
  }
}
console.log(func());//>> func is not defined
```

## 执行上下文

当前JavaScript代码被解析和执行时所在的环境，也叫作执行环境。

JS代码在执行前，JavaScript引擎总要做一番准备工作，这份工作其实就是创建对应的执行上下文

### 种类
执行上下文只有三类:

* **全局**执行上下文
* **函数**执行上下文
* eval上下文 (这个一般不用)

全局执行上下文

全局执行上下文 **只有一个**, 它在客户端中一般由浏览器创建, 也就是window对象, window对象内置了大量方法以及属性, 由于是全局的, 所以在任意位置都能访问到window对象; 同时window还是各种var声明的 **全局对象** 的载体。

1. 函数上下文

函数执行上下文可以有 **无数个**, 每当函数被调用, 就会为其生成一个上下文, 同一个函数执行多次, 依然会再次创建新的执行上下文, 由于函数执行上下文有非常多, 那么JavaScript是如何管理这么多执行上下文的呢?

### 执行栈

还是先上个例子, 这里有多个函数, 它们嵌套执行:

```js
function f1() {
  f2();
  console.log(1);
};

function f2() {
  f3();
  console.log(2);
};

function f3() {
  console.log(3);
};

f1(); // 这里应该输出什么呢?
```

::: details 输出结果
依次输出 `3 2 1`
:::

为什么会产生这个现象, JS难道不是按顺序执行吗? 这里就是 **执行栈** 在起作用, 执行栈管理了多个函数执行上下文的调用顺序

执行栈也叫做调用栈, 既然是栈, 那他就拥有先进后出 (LIFO: Last In First Out) 的特性, 以刚刚的例子来说, 我们来重新模拟执行栈的**执行阶段**:

1. `f1()` 入栈, 开始执行, 发现了`f2()`, 将其入栈 // 此时 `console.log(1)` 并未入栈
2. `f2()` 入栈, 开始执行, 发现了`f3()`, 将其入栈 // 此时 `console.log(2)` 并未入栈
3. `f3()` 入栈, 开始执行, **`console.log(3)` 入栈并执行**
4. `f3()` 执行完毕, `f3()` 出栈, 继续执行 `f2()` 余下的内容, **`console.log(2)` 入栈并执行**
5. 至此`f2()` 执行完毕, `f2()` 出栈, 继续执行 `f1()` 余下的内容, **`console.log(1)` 入栈并执行**
6. 至此`f1()` 执行完毕, `f1()` 出栈

下面来说比较难以理解的 **创建阶段**:

#### 执行栈的创建

...

## this

本文的重头戏来了, 还是先从

