# 考拉悠然前端团队代码开发规范(v1.0)

> 前端代码规范 是根据各大厂规范，取其精华，并结合团队日常业务需求以及团队在日常开发过程中总结提炼出的经验而制定

## HTML部分

- HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明:

```html
<!DOCTYPE html>
```

- 一般情况下统一使用 “UTF-8” 编码(请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”)

```html
<meta charset="UTF-8">
```

- 元素及标签必须闭合
- HTML标签名、类名、标签属性和大部分属性值统一用小写
- 在 HTML 中不能使用小于号 “<” 和大于号 “>”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体
- 统一使用两个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）
- 纯数字输入框，使用 `type="tel"` 而不是 `type="number"`
- 元素属性值使用双引号语法，可以写上的都写上
- 元素嵌套规范，每个块状元素独立一行，内联元素可选

```html
<!-- 推荐 -->
<div>
  <h1></h1>
  <p></p>
</div>
<p><span></span><span></span></p> 
<!-- 不推荐 -->
<div>
  <h1></h1><p></p>
</div>
<p> 
  <span></span>
  <span></span>
</p>
```

- 段落元素与标题元素只能嵌套内联元素

```html
<!-- 推荐 -->
<h1><span></span></h1>
<p><span></span><span></span></p>
<!-- 不推荐 -->
<h1><div></div></h1>
<p><div></div><div></div></p>
```

- 单行注释:一般用于简单的描述，如某些状态描述、属性描述等。注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行

```html
<!-- good -->
<!-- Comment Text -->
<div>...</div>
<!-- bad -->
<div>...</div><!-- Comment Text -->

<div><!-- Comment Text -->
  ...
</div>
```

- 模块注释: 一般用于描述模块的名称以及模块开始与结束的位置,注释内容前后各一个空格字符，&lt;!-- Start Comment Text --&gt; 表示模块开始，&lt;!-- End Comment Text --&gt; 表示模块结束，模块与模块之间相隔一行

```html
推荐写法：
<!-- Start Comment Text A -->
<div class="mod_a">
  ...
</div>
<!-- End Comment Text A -->

<!-- Start Comment Text B -->
<div class="mod_b">
  ...
</div>
<!-- End Comment Text B -->
```

- 文件模版

移动端：

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no" >
<meta name="format-detection" content="telephone=no" >
<title>移动端HTML模版</title>

<!-- Start DNS预解析 -->
<link rel="dns-prefetch" href="">
<!-- End DNS预解析 --> 

<!-- Start 线上样式页面片，开发请直接取消注释引用 -->
<!-- #include virtual="" -->
<!-- End 线上样式页面片 -->

<!-- Start 本地调试，根据开发模式选择调试方式，请开发删除 --> 
<link rel="stylesheet" href="css/index.css" >
<!-- /本地调试方式 -->

<link rel="stylesheet" href="http://srcPath/index.css" >
<!-- /开发机调试方式 -->
<!-- End 本地调试 -->

</head>
<body>

</body>
</html>
```

PC端

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="keywords" content="your keywords">
<meta name="description" content="your description">
<meta name="author" content="author,email address">
<meta name="robots" content="index,follow">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
<meta name="renderer" content="ie-stand">
<title>PC端HTML模版</title>

<!-- Start DNS预解析 --> 
<link rel="dns-prefetch" href="">
<!-- End DNS预解析 --> 

<!-- Start 线上样式页面片，开发请直接取消注释引用 -->
<!-- #include virtual="" -->
<!-- End 线上样式页面片 -->

<!-- Start 本地调试，根据开发模式选择调试方式，请开发删除 --> 
<link rel="stylesheet" href="css/index.css" >
<!-- /本地调试方式 -->

<link rel="stylesheet" href="http://srcPath/index.css" >
<!-- /开发机调试方式 -->
<!-- End 本地调试 -->

</head>
<body>

</body>
</html>

```

## CSS 部分

- 代码风格统一使用展开格式（Expanded）

```css
.kl-wrapper {
  display: block;
  width: 50px;
}
```

- 样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写
- 尽量少用通用选择器 *
- 尽量不使用 ID 选择器
- 不使用无具体语义定义的标签选择器
- 每个选择器后需要追加一个空格: `selector-name { ... }`
- 统一使用**两个空格**进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）
- 每个属性声明末尾都要加分号

### 属性书写顺序

建议遵循以下顺序

- 布局定位属性：`display` / `position` / `float` / `clear` / `visibility` / `overflow`
- 自身属性：`width` / `height` / `margin` / `padding` / `border` / `background`
- 文本属性：`color` / `font` / `text-decoration` / `text-align` / `vertical-align` / `white-space` / `break-word`
- 其他属性：`content` / `cursor` / `border-radius` / `box-shadow` / `text-shadow` / `background:linear-gradient` …

### CSS注释规范

- 注释以字符 `/*` 开始，以字符 `*/` 结束
- 注释不能嵌套

```css
/* Comment Text */
.kl-wrapper {}
```

### SASS规范

> SASS有两种语法格式，一种是 SCSS (Sassy CSS)，另一种是缩进格式（Indented Syntax），有时称之为 Sass。

- SCSS:
SCSS语法基于 CSS 语法扩展，每一个有效的 CSS 文件都是一个有效的具有相同含义的 SCSS 文件，换种说法就是 SCSS 能识别大多数的 CSS hacks 写法和浏览器前缀写法以及早期的 IE 滤镜写法，这种格式以 .scss 作为扩展名。
- Sass:
Sass 使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式.。这种格式以 .sass 作为拓展名

考虑到 SCSS 语法对 CSS 语法友好的兼容性和扩展性，我们在使用 SASS 编写样式的时候，统一使用 SCSS 语法

#### 团队约定

- 全部遵循 CSS 注释规范
- 不使用 `/*!  */` 注释方式
- 注释内不放 SASS 变量

#### 嵌套规范

```scss
/* CSS */
.kl-wrapper {}
body .kl-wrapper {}

/* SCSS */
.kl-wrapper {
  body & {}
}
/* CSS */
.kl-wrapper {}
.kl-wrapper-cover {}
.kl-wrapper-info {}
.kl-wrapper-info-name {}

/* SCSS */
.kl-wrapper {
  &-cover {}
  &-info {
    &-name {}
  }
}
```

#### 属性嵌套

```scss
/* CSS */
.kl-wrapper {
  background-color: red;
  background-repeat: no-repeat;
  background-image: url(/img/icon.png);
  background-position: 0 0;
}

/* SCSS */
.kl-wrapper {
  background: {
    color: red;
    repeat: no-repeat;
    image: url(/img/icon.png);
    position: 0 0;
  }
}
```

#### 变量

可复用属性尽量抽离为页面变量，易于统一维护

```scss
/* CSS */
.kl-wrapper {
  color: red;
  border-color: red;
}

/* SCSS */
$color: red;
.kl-wrapper {
  color: $color;
  border-color: $color;
}
```

#### 混合 @mixin

根据功能定义模块，然后在需要使用的地方通过 @include 调用，避免编码时重复输入代码段

```scss
/* CSS */
.kl-wrapper-1 {
  -webkit-border-radius: 5px;
  border-radius: 5px;
}
.kl-wrapper-2 {
  -webkit-border-radius: 10px;
  border-radius: 10px;
}

/* SCSS */
@mixin radius($radius:5px) {
  -webkit-border-radius: $radius;
  border-radius: $radius;
}
.kl-wrapper-1 {
  @include radius; //参数使用默认值
}
.kl-wrapper-2 {
  @include radius(10px);
}

/* CSS */
.kl-wrapper-1 {
  background: url(/img/icon.png) no-repeat -10px 0;
}
.kl-wrapper-2 {
  background: url(/img/icon.png) no-repeat -20px 0;
}

/* SCSS */
@mixin icon($x:0, $y:0) {
  background: url(/img/icon.png) no-repeat $x, $y;
}
.kl-wrapper-1 {
  @include icon(-10px, 0);
}
.kl-wrapper-2 {
  @include icon(-20px, 0);
}
```

#### 占位选择器 %placeholder

如果不调用则不会有任何多余的 css 文件，占位选择器以 `%` 标识定义，通过 @extend 调用

```scss
/* SCSS */
%borderbox {
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
}
.kl-wrapper {
  @extend %borderbox;
}
```

#### 继承 @extend

```scss
/* CSS */
.kl-wrapper-1 {
  font-size: 12px;
  color: red;
}
.kl-wrapper-2 {
  font-size: 12px;
  color: red;
  font-weight: bold;
}

/* SCSS */
.kl-wrapper-1 {
  font-size: 12px;
  color: red;
}
.kl-wrapper-2 {
  @extend .kl-wrapper-1;
  font-weight: bold;
}

/* 或者如下写法 */
%font_red {
  font-size: 12px;
  color: red;
}
.kl-wrapper-1 {
  @extend %font_red;
}
.kl-wrapper-2 {
  @extend %font_red;
  font-weight: bold;
}
```

#### for 循环

注意：`#{}` 是连接符，变量连接使用时需要依赖

```scss
/* CSS */
.kl-wrapper-1 {background-position: 0 -20px;}
.kl-wrapper-2 {background-position: 0 -40px;}
.kl-wrapper-3 {background-position: 0 -60px;}

/* SCSS */
@for $i from 1 through 3 {
  .kl-wrapper-#{$i} {
    background-position: 0 (-20px) * $i;
  }
}
```

#### each 循环

```scss
/* CSS */
.kl-list {
  background-image: url(/img/kl_list.png);
}
.kl-detail {
  background-image: url(/img/kl_detail.png);
}

/* SCSS */
@each $name in list, detail {
  .kl-#{$name} {
    background-image: url(/img/kl_#{$name}.png);
  }
}


/* CSS */
.kl-list {
  background-image: url(/img/kl_list.png);
  background-color: red;
}
.kl-detail {
  background-image: url(/img/kl_detail.png);
  background-color: blue;
}

/* SCSS */
@each $name, $color in (list, red), (detail, blue) {
  .kl-#{$name} {
    background-image: url(/img/kl_#{$name}.png);
    background-color: $color;
  }
}
```

#### function 函数

```scss
@function pxToRem($px) {
  @return $px / 10px * 1rem;
}
.kl {
  font-size: pxToRem(12px);
}
```

#### 运算规范

> 运算符之间空出一个空格,注意运算单位，单位同时参与运算，所以 10px 不等于 10，乘除运算时需要特别注意

```css
/* 正确的运算格式 */
.kl {
  width: calc(100px - 50px);
  width: calc(100px + 50px);
  width: calc(100px * 2);
  width: calc(100px / 2);
}
```

### 重置样式

- 统一使用normalize.css

### 媒体查询

- 常用查询语句

判断设备横竖屏

```css
/* 横屏 */
@media all and (orientation :landscape) {

} 

/* 竖屏 */
@media all and (orientation :portrait) {

}
```

判断设备宽高

```css
/* 设备宽度大于 320px 小于 640px */
@media all and (min-width:320px) and (max-width:640px) {
    
}
```

判断设备像素比

```css
/* 设备像素比为 1 */
@media only screen and (-webkit-min-device-pixel-ratio: 1), only screen and (min-device-pixel-ratio: 1) {
    
}

/* 设备像素比为 1.5 */
@media only screen and (-webkit-min-device-pixel-ratio: 1.5), only screen and (min-device-pixel-ratio: 1.5) {
    
}

/* 设备像素比为 2 */
@media only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min-device-pixel-ratio: 2) {
    
}
```

## JavaScript 部分

> JavaScript 是一种客户端脚本语言，这里列出了编写 JavaScript 时需要遵守的规则。

### 类型

#### 原始类型

存取原始类型直接作用于值本身

- 布尔类型
- Null 类型
- Undefined 类型
- Number类型
- BigInt 类型
- String类型
- 符号类型 Symbol

#### 复杂类型

访问复杂类型作用于值的引用

- Object类型
- Array 类型
- Function 类型

### 引用

> 请记得 const 和 let 都是块级作用域，var 是函数级作用域

- 对所有引用都使用 const，不要使用 var，`eslint: prefer-const`, `eslint: no-const-assign`
**原因：这样做可以确保你无法重新分配引用，以避免出现错误和难以理解的代码**

- 如果引用是可变动的，使用 `let` 代替 `var`，`eslint: no-var`
**原因：let 是块级作用域的，而不像 var 属于函数级作用域**

### 对象

- 请使用字面量值创建对象，`eslint: no-new-object`
- 别使用保留字作为对象的键值，这样在 IE8 下不会运行
- 当使用动态属性名创建对象时，请使用对象计算属性名来进行创建
**原因：因为这样做就可以让你在一个地方定义所有的对象属性**
- 请使用对象方法的简写方式，`eslint: object-shorthand`
**原因：这样更简短且描述更清楚**

```js
// bad
const item = {
  value: 1,

  addValue: function (val) {
    return item.value + val
  }
}

// good
const item = {
  value: 1,

  addValue (val) {
    return item.value + val
  }
}
```

- 将简写的对象属性分组后统一放到对象声明的开头 **原因：这样更容易区分哪些属性用了简写的方式**

```js
const job = 'FrontEnd'
const department = 'JDC'

// bad
const item = {
  sex: 'male',
  job,
  age: 25,
  department
}

// good
const item = {
  job,
  department,
  sex: 'male',
  age: 25
}
```

- 只对非法标识符的属性使用引号，`eslint: quote-props`
**原因：因为通常来说我们认为这样主观上会更容易阅读，这样会带来代码高亮上的提升，同时也更容易被主流 JS 引擎优化**

```js
// bad
const bad = {
  'foo': 3,
  'bar': 4,
  'data-blah': 5
}

// good
const good = {
  foo: 3,
  bar: 4,
  'data-blah': 5
}
```

- 不要直接使用 `Object.prototype` 的方法, 例如 `hasOwnProperty`, `propertyIsEnumerable` 和 `isPrototypeOf` 方法，`eslint: no-prototype-builtins`
**原因：这些方法可能会被对象自身的同名属性覆盖 - 比如 { hasOwnProperty: false } 或者对象可能是一个 null 对象(Object.create(null))**

```js
// bad
console.log(object.hasOwnProperty(key))

// good
console.log(Object.prototype.hasOwnProperty.call(object, key))

// best
const has = Object.prototype.hasOwnProperty // cache the lookup once, in module scope.
console.log(has.call(object, key))

/* or */
import has from 'has' // https://www.npmjs.com/package/has
console.log(has(object, key))
```

- 优先使用对象展开运算符 `...` 来做对象浅拷贝而不是使用 `Object.assign`，使用对象剩余操作符来获得一个包含确定的剩余属性的新对象

```js
// very bad
const original = { a: 1, b: 2 }
const copy = Object.assign(original, { c: 3 }) // this mutates `original` ಠ_ಠ
delete copy.a // so does this

// bad
const original = { a: 1, b: 2 }
const copy = Object.assign({}, original, { c: 3 }) // copy => { a: 1, b: 2, c: 3 }

// good
const original = { a: 1, b: 2 }
const copy = { ...original, c: 3 } // copy => { a: 1, b: 2, c: 3 }

const { a, ...noA } = copy // noA => { b: 2, c: 3 }
```

### 数组

- 请使用字面量值创建数组，`eslint: no-array-constructor`

```js
// bad
const items = new Array()

// good
const items = []
```

- 向数组中添加元素时，请使用 `push` 方法

```js
const items = []

// bad
items[items.length] = 'test'

// good
items.push('test')
```

- 使用展开运算符 `...` 复制数组

```js
// bad
const items = []
const itemsCopy = []
const len = items.length
let i

// bad
for (i = 0; i < len; i++) {
  itemsCopy[i] = items[i]
}

// good
itemsCopy = [...items]
```

- 把一个可迭代的对象转换为数组时，使用展开运算符 `...` 而不是 `Array.from`

```js
const foo = document.querySelectorAll('.foo')

// good
const nodes = Array.from(foo)

// best
const nodes = [...foo]
```

- 使用 `Array.from` 来将一个类数组对象转换为数组

```js
const arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 }

// bad
const arr = Array.prototype.slice.call(arrLike)

// good
const arr = Array.from(arrLike)
```

- 遍历迭代器进行映射时使用 `Array.from` 代替扩展运算符 `...`, 因为这可以避免创建中间数组

```js
// bad
const baz = [...foo].map(bar)

// good
const baz = Array.from(foo, bar)
```

- 使用数组的 `map()` 等方法时，请使用 `return` 声明，如果是单一声明语句的情况，可省略 `return`

```js
// good
[1, 2, 3].map(x => {
  const y = x + 1
  return x * y
})

// good
[1, 2, 3].map(x => x + 1)

// bad
const flat = {}
[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) => {
  const flatten = memo.concat(item)
  flat[index] = flatten
})

// good
const flat = {}
[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) => {
  const flatten = memo.concat(item)
  flat[index] = flatten
  return flatten
})

// bad
inbox.filter((msg) => {
  const { subject, author } = msg
  if (subject === 'Mockingbird') {
    return author === 'Harper Lee'
  } else {
    return false
  }
})

// good
inbox.filter((msg) => {
  const { subject, author } = msg
  if (subject === 'Mockingbird') {
    return author === 'Harper Lee'
  }

  return false
})
```

- 如果一个数组有多行则要在数组的开括号`[`后和闭括号`]`前使用新行

```js
// bad
const arr = [
  [0, 1], [2, 3], [4, 5]
]

const objectInArray = [{
  id: 1
}, {
  id: 2
}]

const numberInArray = [
  1, 2
]

// good
const arr = [[0, 1], [2, 3], [4, 5]]

const objectInArray = [
  {
    id: 1
  },
  {
    id: 2
  }
]

const numberInArray = [
  1,
  2
]
```

### 解构赋值

- 当需要使用对象的多个属性时，请使用解构赋值，eslint: prefer-destructuring
**原因：解构可以避免创建属性的临时引用**

```js
// bad
function getFullName (user) {
  const firstName = user.firstName
  const lastName = user.lastName

  return `${firstName} ${lastName}`
}

// good
function getFullName (user) {
  const { firstName, lastName } = user

  return `${firstName} ${lastName}`
}

// better
function getFullName ({ firstName, lastName }) {
  return `${firstName} ${lastName}`
}
```

- 当需要使用数组的多个值时，请同样使用解构赋值，`eslint: prefer-destructuring`

```js
const arr = [1, 2, 3, 4]

// bad
const first = arr[0]
const second = arr[1]

// good
const [first, second] = arr
```

- 函数需要回传多个值时，请使用对象的解构，而不是数组的解构
**原因：可以非破坏性地随时增加或者改变属性顺序**

```js
// bad
function doSomething () {
  return [top, right, bottom, left]
}

// 如果是数组解构，那么在调用时就需要考虑数据的顺序
const [top, xx, xxx, left] = doSomething()

// good
function doSomething () {
  return { top, right, bottom, left }
}

// 此时不需要考虑数据的顺序
const { top, left } = doSomething()
```

### 字符串

- 字符串统一使用单引号的形式 `''`，`eslint: quotes`

```js
// bad
const department = "KL"

// good
const department = 'KL'
```

- 字符串太长的时候，请不要使用字符串连接符换行 `\`，而是使用 `+`,或者使用模板字符串

```js
const str = "凹凸实验室 凹凸实验室 凹凸实验室" +
  "凹凸实验室 凹凸实验室 凹凸实验室" +
  "凹凸实验室 凹凸实验室"
```

- 程序化生成字符串时，请使用模板字符串，`eslint: prefer-template template-curly-spacing`

```js
const test = 'test'

// bad
const str = ['a', 'b', test].join()

// bad
const str = 'a' + 'b' + test

// good
const str = `ab${test}`
```

- 不要对字符串使用`eval()`，会导致太多漏洞，`eslint: no-eval`
- 不要在字符串中使用不必要的转义字符， `eslint: no-useless-escape`

```js
// bad
const foo = '\'this\' \i\s \"quoted\"'

// good
const foo = '\'this\' is "quoted"'
const foo = `my name is '${name}'`
```

### 函数

- 不要使用`Function`构造函数创建函数， `eslint: no-new-func`
**原因：此方式创建函数和对字符串使用 eval() 一样会产生漏洞**

```js
// bad
const add = new Function('a', 'b', 'return a + b')

// still bad
const subtract = Function('a', 'b', 'return a - b')
```

- 用圆括号包裹自执行匿名函数，`eslint：wrap-iife`
**原因：一个立即执行匿名函数表达式是一个单一的单元，将其及其调用括号包装在括号中，能够清楚地表达这一点。注意，在到处都是模块的世界中几乎不需要 IIFE。**

```js
// immediately-invoked function expression (IIFE)
(function () {
  console.log('Welcome to the Internet. Please follow me.')
}())
```

- 不要在非函数代码块（`if` , `while` 等）中声明函数，`eslint：no-loop-func`

```js
// bad
if (isUse) {
  function test () {
    // do something
  }
}

// good
let test
if (isUse) {
  test = () => {
    // do something
  }
}
```

- 不要将参数命名为 `arguments`，会导致该参数的优先级高于每个函数作用域内原先存在的 `arguments` 对象

```js
// bad
function foo (name, options, arguments) {
  // ...
}

// good
function foo (name, options, args) {
  // ...
}
```

- 不要使用 `arguments`，使用 剩余运算符 `...`
**注意：arguments 只是一个类数组，而 ... 展开后是一个真正的数组**

```js
// bad
function test () {
  const args = Array.prototype.slice.call(arguments)
  return args.join('')
}

// good
function test (...args) {
  return args.join('')
}
```

- 使用参数默认值语法而不是修改函数参数

```js
// really bad
function handleThings (opts) {
  // No! We shouldn't mutate function arguments.
  // Double bad: if opts is falsy it'll be set to an object which may
  // be what you want but it can introduce subtle bugs.
  opts = opts || {}
  // ...
}

// still bad
function handleThings (opts) {
  if (opts === void 0) {
    opts = {}
  }
  // ...
}

// good
function handleThings (opts = { }) {
  // ...
}
```

- 避免参数默认值的副作用

```js
let b = 1
// bad
function count (a = b++) {
  console.log(a)
}
count()  // 1
count()  // 2
count(3) // 3
count()  // 3
```

- 将参数默认值放在最后

```js
// bad
function handleThings (opts = {}, name) {
  // ...
}

// good
function handleThings (name, opts = {}) {
  // ...
}
```

- 不要更改参数，`eslint: no-param-reassign`
**原因：操作作为参数传入的对象可能在原始调用中造成意想不到的变量副作用**

```js
// bad
function f1 (obj) {
  obj.key = 1
}

// good
function f2 (obj) {
  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1
}
```

- 不要给参数重新赋值，`eslint: no-param-reassign`
**原因：参数重新赋值可能会导致无法预期的行为，尤其是当操作 arguments 对象时，也可能导致优化问题，尤其是在 V8 引擎中**

```js
// bad
function f1 (a) {
  a = 1
}

function f2 (a) {
  if (!a) { a = 1 }
}

// good
function f3 (a) {
  const b = a || 1
}

function f4 (a = 1) {
}
```

- 调用可变参数函数时建议使用展开运算符 `...`， `eslint: prefer-spread`
**原因：显然你无需使用上下文，很难结合 `new` 和 `apply`**

```js
// bad
const x = [1, 2, 3, 4, 5]
console.log.apply(console, x)

// good
const x = [1, 2, 3, 4, 5]
console.log(...x)

// bad
new (Function.prototype.bind.apply(Date, [null, 2021, 8, 5]))

// good
new Date(...[2021, 8, 5])
```

### 箭头函数

- 当你必须使用函数表达式（传递匿名函数）时，使用箭头函数标记. eslint: prefer-arrow-callback, arrow-spacing
**原因：它将创建在 `this` 上下文中执行的函数版本，通常是您想要的，并且语法更简洁,如果您有一个相当复杂的函数，则可以将该逻辑移到其自己的命名函数表达式中**

```js
// bad
[1, 2, 3].map(function (x) {
  const y = x + 1
  return x * y
})

// good
[1, 2, 3].map((x) => {
  const y = x + 1
  return x * y
})
```

- 如果函数体只包含一条没有副作用的返回表达式的语句，可以省略花括号并使用隐式的 return， 否则保留花括号并使用 return 语句，eslint: arrow-parens, arrow-body-style

```js
// bad
[1, 2, 3].map(number => {
  const nextNumber = number + 1
  `A string containing the ${nextNumber}.`
})

// good
[1, 2, 3].map(number => `A string containing the ${number}.`)

// good
[1, 2, 3].map((number) => {
  const nextNumber = number + 1
  return `A string containing the ${nextNumber}.`
})

// good
[1, 2, 3].map((number, index) => ({
  index: number
}))

// No implicit return with side effects
function foo(callback) {
  const val = callback()
  if (val === true) {
    // Do something if callback returns true
  }
}

let bool = false

// bad
foo(() => bool = true)

// good
foo(() => {
  bool = true
})
```

- 一旦表达式跨多行，使用小括号`()`包裹以便更好阅读

```js
// bad
['get', 'post', 'put'].map(httpMethod => Object.prototype.hasOwnProperty.call(
    httpMagicObjectWithAVeryLongName,
    httpMethod
  )
)

// good
['get', 'post', 'put'].map(httpMethod => (
  Object.prototype.hasOwnProperty.call(
    httpMagicObjectWithAVeryLongName,
    httpMethod
  )
))
```

- 函数如果只接收一个参数并且没使用用花括号，则省略圆括号，否则为了清晰明确则使用圆括号包裹参数，注意：总是使用圆括号也是可以接受的，eslint 中的 `"always"` 选项，`eslint: arrow-parens`

```js
// bad
[1, 2, 3].map((x) => x * x)

// good
[1, 2, 3].map(x => x * x)

// good
[1, 2, 3].map(number => (
  `A long string with the ${number}. It’s so long that we’ve broken it ` +
  'over multiple lines!'
))

// bad
[1, 2, 3].map(x => {
  const y = x + 1
  return x * y
})

// good
[1, 2, 3].map((x) => {
  const y = x + 1
  return x * y
})
```

### 类&构造函数

- 使用 `class`，避免直接操作 `prototype`

```js
// bad
function Queue (contents = []) {
  this._queue = [...contents]
}
Queue.prototype.pop = function () {
  const value = this._queue[0]
  this._queue.splice(0, 1)
  return value
}

// good
class Queue {
  constructor (contents = []) {
    this._queue = [...contents]
  }

  pop () {
    const value = this._queue[0]
    this._queue.splice(0, 1)
    return value
  }
}
```

- 使用 extends 来实现继承
**原因：这是一个不会破坏 instanceof 的内建实现原型式继承的方式**

```js
// bad
const inherits = require('inherits')
function PeekableQueue(contents) {
  Queue.apply(this, contents)
}
inherits(PeekableQueue, Queue)
PeekableQueue.prototype.peek = function () {
  return this.queue[0]
}

// good
class PeekableQueue extends Queue {
  peek () {
    return this.queue[0]
  }
}
```

- 如果未声明构造函数，则类会有一个默认的构造函数，没必要用空的构造函数或者将其委托给父类，`eslint: no-useless-constructor`

```js
// bad
class Jedi {
  constructor () {}

  getName() {
    return this.name
  }
}

// bad
class Rey extends Jedi {
  constructor (...args) {
    super(...args)
  }
}

// good
class Rey extends Jedi {
  constructor (...args) {
    super(...args)
    this.name = 'Rey'
  }
}
```

- 避免类成员重复，`eslint: no-dupe-class-members`
**原因：重复的类成员声明会默认使用最后声明的，通常会导致 bug**

```js
// bad
class Foo {
  bar () { return 1 }
  bar () { return 2 }
}

// good
class Foo {
  bar () { return 1 }
}

// good
class Foo {
  bar () { return 2 }
}
```

### 模块

- 使用标准的 ES6 模块语法 import 和 export
**原因：模块是未来，让我们现在开始使用未来的特性**

```js
// bad
const util = require('./util')
module.exports = util

// good
import Util from './util'
export default Util

// better
import { Util } from './util'
export default Util
```

- 不要使用 import 的通配符 *，这样可以确保你只有一个默认的 export

```js
// bad
import * as Util from './util'

// good
import Util from './util'
```

- 同个文件每个模块只允许 import 一次，有多个 import 请书写在一起，`eslint: no-duplicate-imports`
**原因：这样可以让代码更易于维护**

```js
// bad
import foo from 'foo'
// … some other imports … //
import { named1, named2 } from 'foo'

// good
import foo, { named1, named2 } from 'foo'

// good
import foo, {
  named1,
  named2
} from 'foo'
```

- 将所有 import 语句放在文件最前方，`eslint: import/imports-first`

```js
// bad
import foo from 'foo'
foo.init()

import bar from 'bar'

// good
import foo from 'foo'
import bar from 'bar'

foo.init()
```

- 多行导入应该像多行数组和对象文字一样缩进

```js
// bad
import { longNameA, longNameB, longNameC, longNameD, longNameE } from 'path'

// good
import {
  longNameA,
  longNameB,
  longNameC,
  longNameD,
  longNameE
} from 'path'
```

- 在模块 import 声明中禁止使用 Webpack 的 loader 语法，`eslint: import/no-webpack-loader-syntax`

```js
// bad
import fooSass from 'css!sass!foo.scss'
import barCss from 'style!css!bar.css'

// good
import fooSass from 'foo.scss'
import barCss from 'bar.css'
```

### 迭代器

- 不要使用 iterators，建议使用 JS 更高优先级的函数代替 `for-in` 或 `for-of` 循环，除非迫不得已 `eslint: no-iterator no-restricted-syntax`

```js
const numbers = [1, 2, 3, 4, 5]

// bad
let sum = 0
for (let num of numbers) {
  sum += num
}

// good
let sum = 0
numbers.forEach(num => sum += num)

// better
const sum = numbers.reduce((total, num) => total + num, 0)
```

### 生成器

- 现阶段请不要使用生成器 generator **原因：因为不能很好地翻译成 ES5 代码**

### 对象属性

- 使用 `.` 操作符来访问对象属性

```js
const joke = {
  name: 'haha',
  age: 28
}

// bad
const name = joke['name']

// good
const name = joke.name
```

- 当访问的属性是变量时使用 `[]` 的方式来访问

```js
const luke = {
  jedi: true,
  age: 28,
}

function getProp (prop) {
  return luke[prop]
}

const isJedi = getProp('jedi')
```

### 变量声明

- 声明变量时，请使用 `const`、`let` 关键字，如果没有写关键字，变量就会暴露在全局上下文中，这样很可能会和现有变量冲突，另外，也很难明确该变量的作用域是什么。这里推荐使用 `const` 来声明变量，我们需要避免全局命名空间的污染。`eslint: no-undef prefer-const`

```js
// bad
demo = new Demo()

// good
const demo = new Demo()
```

- 将所有的 `const` 和 `let` 分组

```js
// bad
let a
const b = ''
let c
const d = ''
let e

// good
const b = ''
const d = ''
let a
let c
let e
```

- 变量不要进行链式赋值
**原因：变量链式赋值会创建隐藏的全局变量**

```js
// bad
(function example() {
  // JavaScript interprets this as
  // let a = ( b = ( c = 1 ) );
  // The let keyword only applies to variable a; variables b and c become
  // global variables.
  let a = b = c = 1
}())

console.log(a) // throws ReferenceError
console.log(b) // 1
console.log(c) // 1

// good
(function example() {
  let a = 1
  let b = a
  let c = a
}())

console.log(a) // throws ReferenceError
console.log(b) // throws ReferenceError
console.log(c) // throws ReferenceError

// the same applies for `const`
```

- 不允许出现未被使用的变量，`eslint: no-unused-vars`
**原因：声明但未被使用的变量通常是不完全重构犯下的错误.这种变量在代码里浪费空间并会给读者造成困扰**

```js
// bad

var some_unused_var = 42

// Write-only variables are not considered as used.
var y = 10
y = 5

// A read for a modification of itself is not considered as used.
var z = 0
z = z + 1

// Unused function arguments.
function getX (x, y) {
  return x
}

// good

function getXPlusY (x, y) {
  return x + y
}

const x = 1
const y = a + 2

alert(getXPlusY(x, y))

// 'type' is ignored even if unused because it has a rest property sibling.
// This is a form of extracting an object that omits the specified keys.
const { type, ...coords } = data
// 'coords' is now the 'data' object without its 'type' property.
```

### 变量提升(Hoisting)

- `var` 存在变量提升的情况，即 `var` 声明会被提升至该作用域的顶部，但是他们的赋值并不会。而 `const` 和 `let` 并不存在这种情况，他们被赋予了 Temporal Dead Zones(TDZ)， 了解 typeof 不再安全很重要

```js
function example () {
  console.log(notDefined)   // => throws a ReferenceError
}

function example () {
  console.log(declareButNotAssigned)  // => undefined
  var declaredButNotAssigned = true
}

function example () {
  let declaredButNotAssigned
  console.log(declaredButNotAssigned)   // => undefined
  declaredButNotAssigned = true
}

function example () {
  console.log(declaredButNotAssigned)   // => throws a ReferenceError
  console.log(typeof declaredButNotAssigned)  // => throws a ReferenceError
  const declaredButNotAssigned = true
}
```

- 匿名函数的变量名会提升，但函数内容不会

```js
function example () {
  console.log(anonymous)  // => undefined

  anonymous()

  var anonymous = function () {
    console.log('test')
  }
}
```

- 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会

```js
function example() {
  console.log(named)  // => undefined

  named()   // => TypeError named is not a function

  superPower()  // => ReferenceError superPower is not defined

  var named = function superPower () {
    console.log('Flying')
  }
}

function example() {
  console.log(named)  // => undefined

  named()   // => TypeError named is not a function

  var named = function named () {
    console.log('named')
  }
}
```

### 比较运算符&相等

- 使用 `===` 和 `!==` ，`eslint: eqeqeq`
- 条件声明例如 if 会用 ToBoolean 这个抽象方法将表达式转成布尔值并遵循如下规则:

> 1.Objects 等于 true
>
> 2.Undefined 等于 false
>
> 3.Null 等于 false
>
> 4.Booleans 等于 布尔值
>
> 5.Numbers 在 +0, -0, 或者 NaN 的情况下等于 false, 其他情况是 true
>
> 6.Strings 为 '' 时等于 false, 否则是 true

```js
if ([0] && []) {
  // true
  // 数组(即使是空数组)也是对象，对象等于true
}
```

永远**不要直接使用** `undefined` 进行变量判断；可以使用 `typeof` 和字符串`undefined`对变量进行判断。

### 标准特性

- 为了代码的可移植性和兼容性，我们应该最大化的使用标准方法，例如优先使用 `string.charAt(3)` 而不是 `string[3]`
- 由于 `eval` 方法比较 `evil`，所以我们约定禁止使用该方法
- 由于 `with` 方法会产生神奇的作用域，所以我们也是禁止使用该方法的
- 不要修改内置对象，如 `Object` 和 `Array`

### 变量命名

- 当命名变量时，主流分为驼峰式命名（constiableName）和下划线命名（constiable_name）两大阵营。
`团队约定使用驼峰式命名`

- 在 ECMAScript5 里面，对象字面量中的拖尾逗号是合法的，但在 IE8（非 IE8 文档模式）下，当出现拖尾逗号，则会抛出错误。

```js
const foo = {
  name: 'foo',
  age: '22',
}
```

拖尾逗号的好处是，简化了对象和数组添加或删除元素，我们只需要修改新增的行即可，并不会增加差异化的代码行数。
因为拖尾逗号有好也有不好，所以团队约定如下:

- 允许在最后一个元素或属性与闭括号 `]` 或 `}` 在不同行时，可以(但不要求)使用拖尾逗号。
- 当所有元素处于同一行时，禁止使用拖尾逗号。
- 逗号前后的空格可以提高代码的可读性，团队约定在逗号后面使用空格，逗号前面不加空格。

```js
// bad
const foo = 1,bar = 2
const foo = 1 , bar = 2
const foo = 1 ,bar = 2
const foo = {bar: 1, baz: 2,}
const foo = {bar:1,baz:2}

// good
const foo = 1, bar = 2
const foo = { bar: 1, baz: 2 }
```

- 团队约定在对象的计算属性内，禁止使用空格

```js
// bad
obj['foo' ]
obj[ 'foo']
obj[ 'foo' ]

// good
obj['foo']
```

- 拖尾换行:在非空文件中，存在拖尾换行是一个常见的 UNIX 风格，它的好处是可以方便在串联和追加文件时不会打断 Shell 的提示。在日常的项目中，保留拖尾换行的好处是，可以减少版本控制时的代码冲突。*可以通过 .editorconfig 添加 EOL*

```js
// bad
function func () {
  // do something
}

// good
function func () {
  // do something
}
// new empty line
```

- 为了避免语法错误，团队约定在函数调用时，禁止使用空格

### 缩进

代码保持一致的缩进，是作为工程师的职业素养。但缩进用两个空格，还是四个空格，是用 Tab 还是空格呢？这样的争论太多了，也得不出答案。本规范结合了市面上优秀的开源项目，姑且约定使用 空格(space) 来缩进，而且缩进使用两个空格。

*如果习惯了按 Tab 键来缩进, 可以通过配置 .editorconfig ，将 Tab 自动转换为空格。*

- 对象字面量的键值缩进

> 团队约定对象字面量的键和值之间不能存在空格，且要求对象字面量的冒号和值之间存在一个空格

```js
// bad
const obj = { 'foo' : 'haha' }

// good
const obj = { 'foo': 'haha' }
```

- 构造函数首字母大写

> 在 JavaScript 中 `new` 操作符用来创建某个特定类型的对象的一个实例，该类型的对象是由一个构造函数表示的。由于构造函数只是常规函数，唯一区别是使用 `new` 来调用。所以我们团队约定构造函数的首字母要大小，以此来区分构造函数和普通函数。

```js
// bad
const fooItem = new foo()

// good
const fooItem = new Foo()
```

- 构造函数的参数

> 在 JavaScript 中，通过 `new` 调用构造函数时，如果不带参数，可以省略后面的圆括号。但这样会造成与整体的代码风格不一致，所以团队约定使用圆括号

```js
// bad
const person = new Person

// good
const person = new Person()
```

- 链式调用

> 链式调用如果放在同一行，往往会造成代码的可读性差，但有些时候，短的链式调用并不会影响美观。所以本规范约定一行最多只能有**4个**链式调用，超过就要求换行。

```js
// bad
foo.bar.baz.then().finally()

// good
foo.bar.baz.then(res => {
  // do something
}).finally(res => {
  // do something
})
```

- 链式赋值

> 链式赋值容易造成代码的可读性差，所以团队约定**禁止使用链式赋值**

```js
// bad
const a = b = c = 1

// good
const a = 1
const b = 1
const c = 1
```

- 空白行对于分离代码逻辑有帮助，但过多的空行会占据屏幕的空间，影响可读性。团队约定最大连续**2**个空行数

- 变量声明

> JavaScript 允许在一个声明中，声明多个变量。团队约定在声明变量时，一个声明只能有一个变量

```js
// bad
const a, b, c

// good
const a
const b
const c
```

- Unicode 字节顺序标记 (BOM) 用来指定代码单元是高字节序还是低字节序。也就是说，是高位在前还是低位在前。UTF-8 不需要 BOM 来表明字节顺序，因为单个字节并不影响字节顺序。
相信不少同学遇到过 BOM 的坑，这里不多说了，切记不要使用 windows 的记事本改代码！

## 图片规范

### 图片格式

> 常见的图片格式有 GIF、PNG8、PNG24、JPEG、WEBP，根据图片格式的特性和场景需要选取适合的图片格式。

#### GIF

> GIF图象是基于颜色列表的（存储的数据是该点的颜色对应于颜色列表的索引值），最多只支持8位（256色）。GIF文件内部分成许多存储块，用来存储多幅图象或者是决定图象表现行为的控制块，用以实现动画和交互式应用。GIF文件还通过LZW压缩算法压缩图象数据来减少图象尺寸

GIF有如下特性:

> - 优秀的压缩算法使其在一定程度上保证图像质量的同时将体积变得很小。
> - 可插入多帧，从而实现动画效果。
> - 可设置透明色以产生对象浮现于背景之上的效果。
> - 由于采用了8位压缩，最多只能处理256种颜色，故不宜应用于真彩色图片。

#### PNG

> PNG是20世纪90年代中期开始开发的图像文件存储格式，其目的是企图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。流式网络图形格式(Portable Network Graphic Format，PNG)名称来源于非官方的“PNG’s Not GIF”，是一种位图文件(bitmap file)存储格式，读成“ping”。PNG用来存储灰度图像时，灰度图像的深度可多到16位，存储彩色图像时，彩色图像的深度可多到48位，并且还可存储多到16位的α通道数据。PNG使用从LZ77派生的无损数据压缩算法。

PNG有如下特性:

> - 支持256色调色板技术，文件体积小。
> - 无损压缩
> - 最高支持48位真彩色图像以及16位灰度图像。
> - 支持Alpha通道的透明/半透明特性。
> - 支持图像亮度的Gamma校准信息。
> - 支持存储附加文本信息，以保留图像名称、作者、版权、创作时间、注释等信息。
> - 渐近显示和流式读写，适合在网络传输中快速显示预览效果后再展示全貌。
> - 使用CRC防止文件出错。
> - 最新的PNG标准允许在一个文件内存储多幅图像。

#### JPEG

> JPEG是一种针对照片视频而广泛使用的一种有损压缩标准方法。这个名称代表Joint Photographic Experts Group（联合图像专家小组）。此团队创立于公元1986年，1992年发布了JPEG的标准而在1994年获得了ISO 10918-1的认定

JPEG有如下特性:

> - 适用于储存24位元全采影像
> - 采取的压缩方式通常为有损压缩
> - 不支持透明或动画
> - 压缩比越高影像耗损越大，失真越严重
> - 压缩比在10左右肉眼无法辨出压缩图与原图的差别

#### WEBP

> WebP，是一种同时提供了有损压缩与无损压缩的图片文件格式，派生自视频编码格式 VP8，是由Google在购买On2 Technologies后发展出来。WebP最初在2010年发布，2011年11月8日，Google开始让WebP支持无损压缩和透明色的功能，而在2012年8月16日的参考实做libwebp 0.2.0中正式支持

WEBP有如下特性:

> - 同时提供有损压缩和无损压缩两种图片文件格式
> - 文件体积小，无损压缩后，比 PNG 文件少了 45％ 的文件大小；有损压缩后，比 JPEG 文件少了 25% - 34% 文件大小
> - 浏览器兼容差，目前只支持客户端 Chrome 和 Opera 浏览器以及安卓原生浏览器(Andriod 4.0+)

### 图片相关的团队约定

#### 内容图

内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大

> - 优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式
> - 尽量不使用PNG格式，PNG8 色位太低，PNG24 压缩率低，文件体积大

#### 背景图

背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片

> - PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG格式允许更多的颜色并提供更好的压缩率
> - 图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式
> - 图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式
> - 图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式
> - 条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式

#### 图片大小

> - PC平台单张的图片的大小应 **小于200KB**。
> - 移动平台单张的图片的大小应 **小于100KB**。

#### 图片质量

> - 上线的图片都应该经过压缩处理，压缩后的图片不应该出现肉眼可感知的失真区域
> - 60质量的JPEG格式图片与质量大于60的相比，肉眼已看不出明显的区别，因此保存 JPEG 图的时候，质量一般控制在60，若保真度要求高的图片可适量提高到 80，图片大小控制在 200KB 以内

#### 图片引入

> 测试内容图应该写上表明图片尺寸的占位图，可以用线上占位图生成服务，如：
> [http://placeholder.qiniudn.com/300x200](http://placeholder.qiniudn.com/300x200)

### CSS Sprites 和 Data URIs

CSS Sprites 特点

> - 减少请求数
> - 加速图片的显示
> - 维护更新成本大
> - 更多的内存消耗，特别是大体积或有过多空白的 Sprites 图
> - 图片渗漏，相邻的不需展示的图片有可能出现在展示元素中，特别是在高清设备移动设备上
>

Data URIs（base64编码）

> - 减少请求数
> - 转换文件体积大，大约比原始的二进制大33%
> - IE6 / IE7 不支持
> - 图片显示相对较慢，需要更多的CPU消耗

### 使用建议

CSS Sprites 使用建议

> - 适合使用频率高更新频率低的小图标
> - 尽量不留太多的空白
> - 体积较大的图片不合并
> - 确保要合并的小图坐标数值和合并后的 Sprites 图尺寸均为偶数

Data URIs（base64编码）使用建议

> - 适合更新频率高的小图片，如某些具备自定义功能的标题icon等
> - 转换成 Base64 编码的图片应小于 2KB
> - 移动端不使用 Base64 编码
> - 要兼容 IE6/IE7 的不使用

- 处理高清图片的时候，命名应该加上图片相应的精度说明

```css
body {
  /* bad */
  background: url('kl_logo.png');
  background: url('kl_logo_retina.png');

  /* good */
  background: url('kl_logo@1x.png');
  background: url('kl_logo@2x.png');
}
```

## 命名规范

### 目录命名

全部采用小写方式，以中划线分隔，有复数结构时，要采用复数命名法，缩写不用复数

bad
> script / style / demo_scripts / demoStyles / imgs / docs

good
> scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc

- VUE 的项目中的 components 中的组件目录，使用 kebab-case 命名

bad
> HeadSearch / PageLoading

good
> head-search / page-loading / authorized / notice-icon

- VUE 的项目中的除 components 组件目录外的所有目录也使用 kebab-case 命名

bad
> ShoppingCar / UserManagement

good
> page-one / shopping-car / user-management

### CSS 命名规范

- ClassName命名

> - ClassName的命名应该尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用中划线 “-” 连接

命名原则：**基于姓氏命名法（继承 + 外来）**

- 项目命名
全部采用小写方式， 以中划线分隔。

```css
/* bad */
.mall_management-system {}
.mallManagementSystem {}

/* good */
.mall-management-system {}
```

> - ID 和 class 的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称
> - 类名使用小写字母，以中划线分隔
> - id 采用驼峰式命名
> - scss 中的变量、函数、混合、placeholder 采用驼峰式命名

### Javascript 命名规范

> - 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束
> - 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式

其中 method 方法命名必须是 *动词* 或者 *动词+名词* 形式

bad
> save / open / show / go

good
> saveShopCarData /openShopCarInfoDialog

常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。

## Vue 项目规范

vue 项目规范以 Vue 官方规范 [https://cn.vuejs.org/v2/style-guide](https://cn.vuejs.org/v2/style-guide) 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。**请仔仔细细阅读 Vue 官方规范，切记，此为第一步。**

### 组件规范

#### 组件名为多个单词

> 组件名应该始终是多个单词组成（大于等于 2），且命名规范为KebabCase格式。
  这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。

```js
// bad
export default {
  name: 'Todo',
  // ...
}
export default {
  name: 'todo-item',
  // ...
}

// good
export default {
  name: 'TodoItem'
  // ...
};
```

#### 组件文件名为 pascal-case 格式

good
> components
> └ my-component.vue

bad
> components
> ├ myComponent.vue
> └ MyComponent.vue

#### 基础组件文件名为 base 开头，使用完整单词而不是缩写

bad
> components
> ├ MyButton.vue
> ├ VueTable.vue
> └ Icon.vue

good
> components
> ├ base-button.vue
> ├ base-table.vue
> └ base-icon.vue

#### 和父组件紧密耦合的子组件应该以父组件名作为前缀命名

bad
> components/
> ├ TodoList.vue
> ├ TodoItem.vue
> ├ TodoButton.vue
> └ UProfOpts.vue （使用了缩写）

good
> components/
> ├ todo-list.vue
> ├ todo-list-item.vue
> ├ todo-list-item-button.vue
> └ user-profile-options.vue （完整单词）

#### 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件

```html
<!-- bad -->
<my-component />
<row>
  <table :column="data"/>
</row>

<!-- good -->
<!-- 在单文件组件、字符串模板和 JSX 中 -->
<MyComponent />
<Row>
  <table :column="data"/>
</Row>
```

#### 组件的 data 必须是一个函数

> 当在组件中使用 `data` 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。

```js
// bad
export default {
  data: {
    name: 'jack'
  }
}

// good
export default {
  data () {
    return {
      name: 'jack'
    }
  }
}
```

7、为了更直观的定义`data`, 可以将不同区域的数据直接放置于不同的对象下, 方便统一维护, 同时也避免了在同一根对象下命名太冗长的问题

```js
// bad
data() {
  return {
    name: '',
    gender: 1,
    age: 1
    // 通常是同区块的数据放置在一起 不同的区块用换行隔开

    dialogOneVisible: false,
    dialoOneTitle: '标题1',
    dialoOneContent: '内容1',

    dialogTwoVisible: false,
    dialogTwoTitle: '标题2',
    dialogTwoContent: '内容2',

    form: {
      keyword: '',
      type: 1,
    },
    // ...
  }
}
// good
data() {
  return {
    userInfo: {
      name: '',
      gender: 1,
      age: 1
    },
    form: { ... }, // 置于上方
    dialogOneInfo: {
      visible: false,
      title: '标题1',
      content: '内容1',
    }
    dialogTwoInfo: {
      visible: false,
      title: '标题2',
      content: '内容2',
    }
    // ...
  }
}
```

#### 组件内方法，数据命名尽量统一，方便复用

#### Prop 定义应该尽量详细

> - 必须使用 camelCase 驼峰命名
> - 必须指定类型
> - 必须加上注释，表明其含义
> - 必须加上 required 或者 default，两者二选其一
> - 如果有业务需要，必须加上 validator 验证

```js
props: {
  // 组件状态，用于控制组件的颜色
  status: {
    type: String,
    required: true,
    validator: function (value) {
     return [
        'succ',
        'info',
        'error'
      ].indexOf(value) !== -1
    }
  },
  // 用户级别，用于显示皇冠个数
  userLevel：{
    type: String,
    required: true
  }
}
```

#### 为组件样式设置作用域

```html
<!-- bad -->
<template>
  <button class="btn btn-close">X</button>
</template>
<!-- 没有使用 `scoped` 特性 -->
<style>
  .btn-close {
    background-color: red;
  }
</style>

<!-- good -->
<template>
  <button class="btn btn-close">X</button>
</template>
<!-- 使用 `scoped` 特性 -->
<style scoped>
  .btn-close {
    background-color: red;
  }
</style>
```

#### 如果特性元素较多，应该主动换行

```html
<!-- bad -->
<MyComponent foo="a" bar="b" baz="c" foo="a" bar="b" baz="c" foo="a" bar="b" baz="c" foo="a" bar="b" baz="c"/>

<!-- good -->
<MyComponent foo="a" bar="b" baz="c"
  foo="a" bar="b" baz="c"
  foo="a" bar="b" baz="c"
/>
```

#### 模板中使用简单的表达式

组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。

```html
<!-- good -->
<template>
  <p>{{ normalizedFullName }}</p>
</template>
// 复杂表达式已经移入一个计算属性
<script>
  export default {
    // ...
    computed: {
      normalizedFullName: function () {
        return this.fullName.split(' ').map(function (word) {
          return word[0].toUpperCase() + word.slice(1)
        }).join(' ')
      }
    }
  }
</script>

<!-- bad -->
<template>
  <p>
    {{
      fullName.split(' ').map(function (word) {
          return word[0].toUpperCase() + word.slice(1)
        }).join(' ')
    }}
  </p>
</template>
```

#### 指令都使用缩写形式

指令推荐都使用缩写形式，(用 `:` 表示 v-bind: 、用 `@` 表示 v-on: 和用 `#` 表示 v-slot:)

```html
<!-- bad -->
<input
  v-on:input="onInput"
  @focus="onFocus"
>

<!-- good -->
<input
  @input="onInput"
  @focus="onFocus"
>
```

#### 标签顺序保持一致

> 单文件组件应该总是让标签顺序保持一致

```html
<!-- bad -->
<template></template>
<style></style>
<script></script>

<!-- good -->
<template></template>
<script></script>
<style></style>
```

#### 必须为 v-for 设置键值 key

唯一 `key` 可以强制vue进行页面更新

#### v-show 与 v-if 选择

> 如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。

#### script 标签内部结构顺序建议

> components > props > data > computed > watch > filter > 钩子函数（钩子函数按其执行顺序） > methods

### Vue Router 规范

#### 页面跳转数据传递使用路由参数

页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。

```js
// good
let id = '123';
this.$router.push({ name: 'userCenter', query: { id: id } });
```

#### 使用路由懒加载（延迟加载）机制

```js
{
  path: '/uploadAttachment',
  name: 'uploadAttachment',
  meta: {
    title: '上传附件'
  },
  component: () => import('@/view/components/uploadAttachment/index.vue')
},
```

#### router 中的命名规范

path、childrenPoints 命名规范采用kebab-case命名规范（尽量vue文件的目录结构保持一致，因为目录、文件名都是kebab-case，这样很方便找到对应的文件）

name 命名规范采用KebabCase命名规范且和component组件名保持一致！（因为要保持keep-alive特性，keep-alive按照component的name进行缓存，所以两者必须高度保持一致）

```js
// 动态加载export const reload = [
{
  path: '/reload',
  name: 'reload',
  component: Main,
  meta: {
    title: '动态加载',
    icon: 'icon iconfont'
  },

  children: [
    {
      path: '/reload/smart-reload-list',
      name: 'SmartReloadList',
      meta: {
        title: 'SmartReload',
        childrenPoints: [
          {
            title: '查询',
            name: 'smart-reload-search'
          },
          {
            title: '执行reload',
            name: 'smart-reload-update'
          },
          {
            title: '查看执行结果',
            name: 'smart-reload-result'
          }
        ]
      },
      component: () =>
        import('@/views/reload/smart-reload/smart-reload-list.vue')
    }
  ]
}];
```

#### router 中的 path 命名规范

path除了采用kebab-case命名规范以外，必须以 `/` 开头，**即使是children里的path也要以 `/` 开头**。

> 目的：
经常有这样的场景：某个页面有问题，要立刻找到这个vue文件，如果不用以/开头，path为parent和children组成的，可能经常需要在router文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件

```js
{
  path: '/file',
  name: 'File',
  component: Main,
  meta: {
    title: '文件服务',
    icon: 'ios-cloud-upload'
  },
  children: [
    {
      path: '/file/file-list',
      name: 'FileList',
      component: () => import('@/views/file/file-list.vue')
    },
    {
      path: '/file/file-add',
      name: 'FileAdd',
      component: () => import('@/views/file/file-add.vue')
    },
    {
      path: '/file/file-update',
      name: 'FileUpdate',
      component: () => import('@/views/file/file-update.vue')
    }
  ]
}
```

### Vue 项目目录规范

- 使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。
- 目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。

```js
src                            源码目录
├ api                          所有api接口
├ assets                       静态资源，images, icons, styles等
├ components                   公用组件
├ config                       配置信息
├ constants                    常量信息，项目所有Enum, 全局常量等
├ directives                   自定义指令
├ filters                      过滤器，全局工具
├ datas                        模拟数据，临时存放
├ lib                          外部引用的插件存放及修改文件
├ mock                         模拟接口，临时存放
├ plugins                      插件，全局使用
├ router                       路由，统一管理
├ store                        vuex, 统一管理
├ themes                       自定义样式主题
├ views                        视图目录
| ├ role                       role模块名
| | ├ role-list.vue            role列表页面
| | ├ role-add.vue             role新建页面
| | ├ role-update.vue          role更新页面
| | └ index.less               role模块样式
| └ ─ components               role模块通用组件文件夹 
└ employee                     employee模块
```

#### api 目录

> - 文件、变量命名要与后端保持一致。
> - 此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。
> - api 中的方法名字要与后端 api url 尽量保持语义高度一致性。
> - 对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。

后端 url： EmployeeController.java

> /employee/add
> /employee/delete/{id}
> /employee/update

前端： employee.js

```js
// 添加员工
addEmployee: (data) => {
  return postAxios('/employee/add', data)
},
// 更新员工信息
updateEmployee: (data) => {
  return postAxios('/employee/update', data)
},
  // 删除员工
deleteEmployee: (employeeId) => {
  return postAxios('/employee/delete/' + employeeId)
},
```

#### assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case

> assets
> ├ icons
> ├ images
> │ ├ background-color.png
> │ └ upload-header.png
> └ styles

- 尽量不要手动操作 DOM

> 因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。

- 删除无用代码

> 因使用了 git/svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。
