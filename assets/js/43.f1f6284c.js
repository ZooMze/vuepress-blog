(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{625:function(e,t,a){"use strict";a.r(t);var v=a(5),s=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"小程序的原生组件渲染层级的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小程序的原生组件渲染层级的问题"}},[e._v("#")]),e._v(" 小程序的原生组件渲染层级的问题")]),e._v(" "),a("p",[e._v("小程序中有的组件是由原生的方式进行渲染的, 例如图表、picker-view, 它们的层级是绝对高于普通的页面元素, 无论在普通页面元素中使用多高的 "),a("code",[e._v("z-index")]),e._v(" 属性也无法超过这些原生组件的层级")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("疑惑")]),e._v(" "),a("p",[e._v("在开发者工具中调试时, 确实会出现上述图表层级超越页面元素的问题, 但是实际测试时, 在大多数手机中此层级问题却不是必现问题")])]),e._v(" "),a("p",[e._v("为了解决这个穿透的问题, 尝试使用了 "),a("code",[e._v("cover-view")]),e._v(" 组件, 它同样由原生组件渲染, 所以它的层级可以超越图表, 按照官方文档的理论如此, 但实际在明厨亮灶小程序中却没有一处改写为 "),a("code",[e._v("cover-view")]),e._v(" 生效的内容, 原因可能是由于渲染先后的关系, 导致导航处的 "),a("code",[e._v("cover-view")]),e._v(" 仍然无法覆盖页面内的图表显示层级, 及时按照文档修改了 "),a("code",[e._v("z-index")]),e._v(" 的属性依旧无法覆盖")]),e._v(" "),a("p",[e._v("最终的解决方案为弹出日历picker时将图表内容隐藏, 用其余占位内容保证页面不出现变化, 让用户尽量无感知, 但这个方案仍然有问题, 即图表滑动到页面顶部时时会覆盖掉顶部的自定义导航(目前这个自定义导航使用的是第三方插件, 并非使用了"),a("code",[e._v("cover-view")]),e._v("), 短时间内无法完美适配")]),e._v(" "),a("p",[e._v("以后的小程序在开发前就要注意到这个"),a("strong",[e._v("原生组件的渲染层级问题")])]),e._v(" "),a("p",[e._v("uni-app中的层级说明: "),a("a",{attrs:{href:"https://uniapp.dcloud.io/component/native-component",target:"_blank",rel:"noopener noreferrer"}},[e._v("uni-app原生组件说明"),a("OutboundLink")],1),e._v("\nwx-weapp的cover-view: "),a("a",{attrs:{href:"https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("微信官方文档cover-view的说明"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"小程序的storage的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小程序的storage的问题"}},[e._v("#")]),e._v(" 小程序的Storage的问题")]),e._v(" "),a("p",[e._v("小程序在获取getStorageSync时可能会遇到无法获取到值的问题, 这个问题在切出小程序再次回到小程序时稳定重现, 可能会导致数据丢失进而影响功能")]),e._v(" "),a("p",[e._v("为了解决以及避免问题再现, 应该将所有需要的数据在created/mounted时, 先将数据存储在组件内, 则不会丢失数据")]),e._v(" "),a("h2",{attrs:{id:"小程序流媒体播放"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小程序流媒体播放"}},[e._v("#")]),e._v(" 小程序流媒体播放")]),e._v(" "),a("p",[e._v("小程序支持内置的流媒体播放方案: 但仅支持两种格式的流: "),a("code",[e._v(".flv")]),e._v(" 和 "),a("code",[e._v(".rtmp")]),e._v(";")]),e._v(" "),a("p",[e._v("同时并非直接使用video标签, 而是使用 "),a("code",[e._v("<live-player>")]),e._v(" 标签, 它与传统的 "),a("code",[e._v("<video>")]),e._v(" 不同, 内置的内容比video少很多, 甚至全屏功能也不能直接在标签内设置属性控制;")]),e._v(" "),a("p",[e._v("需要控制全屏功能时需要先使用 "),a("code",[e._v("createLivePlayerContext()")]),e._v(" 获取 "),a("code",[e._v("<live-player>")]),e._v(" 的实例, 然后再调用 "),a("code",[e._v("requestFullScreen()")]),e._v(" 这个API, 并在成功 "),a("code",[e._v("success")]),e._v(" 和失败 "),a("code",[e._v("fail")]),e._v(" 回调中处理你的代码逻辑")]),e._v(" "),a("p",[e._v("同时全屏后的内容例如退出全屏按钮, 返回按钮等, 都需要写在 "),a("code",[e._v("<live-player>")]),e._v(" 标签内部, 最好是使用 "),a("code",[e._v("<cover-view>")]),e._v(" 和"),a("code",[e._v("<cover-image>")]),e._v(", 并设置较高层级, 以防止这些内容被视频内容遮挡(即上面的层级问题)")]),e._v(" "),a("h2",{attrs:{id:"小程序的列表与详情相关交互"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小程序的列表与详情相关交互"}},[e._v("#")]),e._v(" 小程序的列表与详情相关交互")]),e._v(" "),a("p",[e._v("在移动页面中, 通常是不会出现类似pc上的"),a("code",[e._v("dialog")]),e._v("窗口交互的模式, 通常详情即是一个全新的页面(detail page), 在新页面中还会附带一些影响列表页(list page)的操作, 例如修改状态, 删除条目等")]),e._v(" "),a("p",[e._v("小程序的页面跳转逻辑类似keep-alive, 进入详情页时, 列表页内容将会全部缓存, 这就导致详情页的操作将会影响列表页, 回到列表页直接刷新整个列表将会非常臃肿, 而且让用户回到上次浏览位置也需要记录页码 "),a("code",[e._v("pageNo")]),e._v(" 和高度 "),a("code",[e._v("scrollHeight")]),e._v(" 信息, 相比恶心的高度计算, 记录当条记录的 "),a("code",[e._v("id")]),e._v(" 和 "),a("code",[e._v("index")]),e._v(" 就显得非常直观和简单")]),e._v(" "),a("h3",{attrs:{id:"修改状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#修改状态"}},[e._v("#")]),e._v(" 修改状态")]),e._v(" "),a("p",[e._v("修改状态时, 返回列表只刷新对应的条目, 此时只需要只需记录其 "),a("code",[e._v("id")]),e._v(" 和 "),a("code",[e._v("pageNo")]),e._v(", 当回到列表页时只需"),a("strong",[e._v("重新获取")]),e._v("这一页的数据, 再比对 "),a("code",[e._v("id")]),e._v(" 后更新列表对应的条目即可")]),e._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[e._v("注意")]),e._v(" "),a("p",[e._v("注意此时重新获取时, 不仅要重新附带当前的全部筛选条件, 还可能会由于数据更新导致本应处于第n页的数据被挤到了第n页后, 为了再次查询到目标条目所以此时"),a("code",[e._v("pageSize")]),e._v("应该被适当放大, 根据这个列表的更新频率来决定 "),a("code",[e._v("pageSize")]),e._v(" 应该放到多大")])]),e._v(" "),a("h3",{attrs:{id:"删除条目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除条目"}},[e._v("#")]),e._v(" 删除条目")]),e._v(" "),a("p",[e._v("删除(或者说是操作导致列表在当前筛选条件下消失), 此时记录 "),a("code",[e._v("index")]),e._v(" 和 "),a("code",[e._v("pageNo")]),e._v(", 返回列表时将对应条目删除")]),e._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("delete")]),e._v(" listData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("虽然这里是假删除, 但是也不用在意这么做的风险性, 因为这是详情页的处理成功回调后续, 这里删除肯定是不会产生错误的, 除非服务端错误...")]),e._v(" "),a("h2",{attrs:{id:"自己的cdn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自己的cdn"}},[e._v("#")]),e._v(" 自己的CDN")]),e._v(" "),a("p",[e._v("明厨亮灶云平台中的富文本功能中使用了tinymce.js, 并且使用了通过url进行加载的方法, url为挂在jsDELIVER的CDN, 但是这个CDN并非国内CDN且不稳定, 导致目前经常会出现富文本加载失败的情况, 因此结合实际和公司内已有的服务器资源, 将同版本的tinymce存放在公司的阿里服务器中, 初次实践时发现js能加载成功, 但是字体图表全部无法成功加载, 浏览器报跨域错误, 最后在阿里服务器中配置了可访问网址白名单即解决")]),e._v(" "),a("h2",{attrs:{id:"ws代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ws代理"}},[e._v("#")]),e._v(" ws代理")]),e._v(" "),a("p",[e._v("在现有项目中, 获取流视频为通常的ws服务器配置代理, 在本地项目中配置代理时可以直接地址为ws/wss, 但NGINX目前无法直接配置这种代理, 配置的地址依然需要http/https, 并将其升级为websocket")]),e._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[e._v("location /httpurl/ "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  proxy_pass http://wsbackendurl"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  proxy_http_version "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1.1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  proxy_set_header Upgrade "),a("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$http_upgrade")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  proxy_set_header Connection "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"upgrade"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("h2",{attrs:{id:"更加统一的日期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更加统一的日期"}},[e._v("#")]),e._v(" 更加统一的日期")]),e._v(" "),a("p",[e._v("由泛华航空园区项目引发的思考, 在页面间跳转时, 时间控件的不统一导致了不少麻烦事, 为了避免类似的问题再次发生, 日期的相关内容需要更加规范化: 例如时间控件的统一, 全局时间格式化方式的统一等")]),e._v(" "),a("p",[e._v("时间控件的统一需要开发与产品一同协商, 属于不完全由开发掌控的问题, 但是时间格式化可以完全由开发决定(当然也涵盖前后台的时间参数传递之间的统一), 以下有几种思路")]),e._v(" "),a("h3",{attrs:{id:"date-format"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#date-format"}},[e._v("#")]),e._v(" Date.Format")]),e._v(" "),a("p",[e._v("传统的格式化方法, 但是通常都需要修改 "),a("code",[e._v("Date")]),e._v(" 对象的构造函数, 格式化代码一搜一大堆→_→")]),e._v(" "),a("p",[e._v("通常情况下不建议这么做, 因为不排除使用的某个第三方库也去修改了 "),a("code",[e._v("Date")]),e._v(" 原型上的函数, 从而导致一些不必要的bug")]),e._v(" "),a("h3",{attrs:{id:"intl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#intl"}},[e._v("#")]),e._v(" Intl")]),e._v(" "),a("p",[a("code",[e._v("Intl")]),e._v(" 对象是 ECMAScript 国际化 API 的一个命名空间，它提供了精确的字符串对比、数字格式化，和日期时间格式化。"),a("code",[e._v("Collator")]),e._v("，"),a("code",[e._v("NumberFormat")]),e._v(" 和 "),a("code",[e._v("DateTimeFormat")]),e._v(" 对象的构造函数是 "),a("code",[e._v("Intl")]),e._v(" 对象的属性。")]),e._v(" "),a("h3",{attrs:{id:"temporal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#temporal"}},[e._v("#")]),e._v(" Temporal")]),e._v(" "),a("p",[a("code",[e._v("Temporal")]),e._v(" 也是一个实验性的方案, 但目前支持度不高, 属于未来可期型")]),e._v(" "),a("h3",{attrs:{id:"第三方库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三方库"}},[e._v("#")]),e._v(" 第三方库")]),e._v(" "),a("p",[e._v("时间相关组件库中, "),a("a",{attrs:{href:"http://momentjs.cn/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Moment.js"),a("OutboundLink")],1),e._v(" 是最全面最历史悠久的库, 随着时间的迭代其包体积对于一个时间库来说已经比较大了(2.24.0.min ~ 16kb), 但是实际项目中可能就使用了一些format之类的API, 实属有点小题大做, 同时还存在一个根本的问题: 其对象是可变的, 意味着为了避免多个时间干扰, 都需要进行克隆"),a("code",[e._v(".clone()")]),e._v(";")]),e._v(" "),a("p",[a("s",[e._v("目前momentjs已经停止开发, 进入维护阶段了")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://dayjs.gitee.io/zh-CN/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Day.js"),a("OutboundLink")],1),e._v("就是更加合适的库, 它拥有极小的体积( ~ 2kb), 以及与moment.js近乎一致的体验, 而且解决了上述可变对象的问题, 每次调用结果都是全新的对象")]),e._v(" "),a("h2",{attrs:{id:"小程序规范"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小程序规范"}},[e._v("#")]),e._v(" 小程序规范")]),e._v(" "),a("p",[e._v("项目或产品中需要小程序时, 不仅开发要遵守小程序的开发规范, 产品角度也需要遵守小程序的规范")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://developers.weixin.qq.com/miniprogram/product/reject.html#_3-1-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%AE%A1%E6%A0%B8%E8%A7%84%E8%8C%83",target:"_blank",rel:"noopener noreferrer"}},[e._v("小程序整体审核规则"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("避免如上出现的问题会让小程序的迷之审核通过率大大提高...")]),e._v(" "),a("p",[e._v("同时小程序以后的方向需要原生小程序进行, 虽然跟通常的web-vue应用开发模式不同, 但有着官方更好的支持、更多踩过的坑以及更官方的社区")]),e._v(" "),a("h2",{attrs:{id:"element"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#element"}},[e._v("#")]),e._v(" Element+")]),e._v(" "),a("p",[e._v('2020-11-30日, 下一代的element+ beta版发布了, 开发者称: "以vue3的方式几乎重写了element的每一行代码", 将来项目中使用vue3开发项目时, 这将是一个很好的选择')]),e._v(" "),a("p",[a("s",[e._v("目前vue3的官中文档加载还是非常龟速")])]),e._v(" "),a("h2",{attrs:{id:"如何让强制浏览器不自动填充账号密码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何让强制浏览器不自动填充账号密码"}},[e._v("#")]),e._v(" 如何让强制浏览器不自动填充账号密码")]),e._v(" "),a("p",[e._v("目前只找到了一种较为可行的方法, 即在input前重复添加一个假的input内容来骗浏览器的自动填充, 但目前对于这种方式仅仅能完美拦截账号的填充, 密码的自动填充即使加上了"),a("code",[e._v("autocomplete='off'")]),e._v(", 浏览器仍然会在你以保存的密码中进行自动选择, 应该是浏览器的自动识别 "),a("code",[e._v("type='password'")]),e._v(" 导致的")])])}),[],!1,null,null,null);t.default=s.exports}}]);